<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - backend\node_modules\@mapbox\node-pre-gyp\lib\util\versioning.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>backend\node_modules\@mapbox\node-pre-gyp\lib\util\versioning.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.37</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">335</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">60.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.38</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

module.exports = exports;

const path = require(&#039;path&#039;);
const semver = require(&#039;semver&#039;);
const url = require(&#039;url&#039;);
const detect_libc = require(&#039;detect-libc&#039;);
const napi = require(&#039;./napi.js&#039;);

let abi_crosswalk;

// This is used for unit testing to provide a fake
// ABI crosswalk that emulates one that is not updated
// for the current version
if (process.env.NODE_PRE_GYP_ABI_CROSSWALK) {
  abi_crosswalk = require(process.env.NODE_PRE_GYP_ABI_CROSSWALK);
} else {
  abi_crosswalk = require(&#039;./abi_crosswalk.json&#039;);
}

const major_versions = {};
Object.keys(abi_crosswalk).forEach((v) =&gt; {
  const major = v.split(&#039;.&#039;)[0];
  if (!major_versions[major]) {
    major_versions[major] = v;
  }
});

function get_electron_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error(&#039;get_electron_abi requires valid runtime arg&#039;);
  }
  if (typeof target_version === &#039;undefined&#039;) {
    // erroneous CLI call
    throw new Error(&#039;Empty target version is not supported if electron is the target.&#039;);
  }
  // Electron guarantees that patch version update won&#039;t break native modules.
  const sem_ver = semver.parse(target_version);
  return runtime + &#039;-v&#039; + sem_ver.major + &#039;.&#039; + sem_ver.minor;
}
module.exports.get_electron_abi = get_electron_abi;

function get_node_webkit_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error(&#039;get_node_webkit_abi requires valid runtime arg&#039;);
  }
  if (typeof target_version === &#039;undefined&#039;) {
    // erroneous CLI call
    throw new Error(&#039;Empty target version is not supported if node-webkit is the target.&#039;);
  }
  return runtime + &#039;-v&#039; + target_version;
}
module.exports.get_node_webkit_abi = get_node_webkit_abi;

function get_node_abi(runtime, versions) {
  if (!runtime) {
    throw new Error(&#039;get_node_abi requires valid runtime arg&#039;);
  }
  if (!versions) {
    throw new Error(&#039;get_node_abi requires valid process.versions object&#039;);
  }
  const sem_ver = semver.parse(versions.node);
  if (sem_ver.major === 0 &amp;&amp; sem_ver.minor % 2) { // odd series
    // https://github.com/mapbox/node-pre-gyp/issues/124
    return runtime + &#039;-v&#039; + versions.node;
  } else {
    // process.versions.modules added in &gt;= v0.10.4 and v0.11.7
    // https://github.com/joyent/node/commit/ccabd4a6fa8a6eb79d29bc3bbe9fe2b6531c2d8e
    return versions.modules ? runtime + &#039;-v&#039; + (+versions.modules) :
      &#039;v8-&#039; + versions.v8.split(&#039;.&#039;).slice(0, 2).join(&#039;.&#039;);
  }
}
module.exports.get_node_abi = get_node_abi;

function get_runtime_abi(runtime, target_version) {
  if (!runtime) {
    throw new Error(&#039;get_runtime_abi requires valid runtime arg&#039;);
  }
  if (runtime === &#039;node-webkit&#039;) {
    return get_node_webkit_abi(runtime, target_version || process.versions[&#039;node-webkit&#039;]);
  } else if (runtime === &#039;electron&#039;) {
    return get_electron_abi(runtime, target_version || process.versions.electron);
  } else {
    if (runtime !== &#039;node&#039;) {
      throw new Error(&quot;Unknown Runtime: &#039;&quot; + runtime + &quot;&#039;&quot;);
    }
    if (!target_version) {
      return get_node_abi(runtime, process.versions);
    } else {
      let cross_obj;
      // abi_crosswalk generated with ./scripts/abi_crosswalk.js
      if (abi_crosswalk[target_version]) {
        cross_obj = abi_crosswalk[target_version];
      } else {
        const target_parts = target_version.split(&#039;.&#039;).map((i) =&gt; { return +i; });
        if (target_parts.length !== 3) { // parse failed
          throw new Error(&#039;Unknown target version: &#039; + target_version);
        }
        /*
                    The below code tries to infer the last known ABI compatible version
                    that we have recorded in the abi_crosswalk.json when an exact match
                    is not possible. The reasons for this to exist are complicated:

                       - We support passing --target to be able to allow developers to package binaries for versions of node
                         that are not the same one as they are running. This might also be used in combination with the
                         --target_arch or --target_platform flags to also package binaries for alternative platforms
                       - When --target is passed we can&#039;t therefore determine the ABI (process.versions.modules) from the node
                         version that is running in memory
                       - So, therefore node-pre-gyp keeps an &quot;ABI crosswalk&quot; (lib/util/abi_crosswalk.json) to be able to look
                         this info up for all versions
                       - But we cannot easily predict what the future ABI will be for released versions
                       - And node-pre-gyp needs to be a `bundledDependency` in apps that depend on it in order to work correctly
                         by being fully available at install time.
                       - So, the speed of node releases and the bundled nature of node-pre-gyp mean that a new node-pre-gyp release
                         need to happen for every node.js/io.js/node-webkit/nw.js/atom-shell/etc release that might come online if
                         you want the `--target` flag to keep working for the latest version
                       - Which is impractical ^^
                       - Hence the below code guesses about future ABI to make the need to update node-pre-gyp less demanding.

                    In practice then you can have a dependency of your app like `node-sqlite3` that bundles a `node-pre-gyp` that
                    only knows about node v0.10.33 in the `abi_crosswalk.json` but target node v0.10.34 (which is assumed to be
                    ABI compatible with v0.10.33).

                    TODO: use semver module instead of custom version parsing
                */
        const major = target_parts[0];
        let minor = target_parts[1];
        let patch = target_parts[2];
        // io.js: yeah if node.js ever releases 1.x this will break
        // but that is unlikely to happen: https://github.com/iojs/io.js/pull/253#issuecomment-69432616
        if (major === 1) {
          // look for last release that is the same major version
          // e.g. we assume io.js 1.x is ABI compatible with &gt;= 1.0.0
          while (true) {
            if (minor &gt; 0) --minor;
            if (patch &gt; 0) --patch;
            const new_iojs_target = &#039;&#039; + major + &#039;.&#039; + minor + &#039;.&#039; + patch;
            if (abi_crosswalk[new_iojs_target]) {
              cross_obj = abi_crosswalk[new_iojs_target];
              console.log(&#039;Warning: node-pre-gyp could not find exact match for &#039; + target_version);
              console.log(&#039;Warning: but node-pre-gyp successfully choose &#039; + new_iojs_target + &#039; as ABI compatible target&#039;);
              break;
            }
            if (minor === 0 &amp;&amp; patch === 0) {
              break;
            }
          }
        } else if (major &gt;= 2) {
          // look for last release that is the same major version
          if (major_versions[major]) {
            cross_obj = abi_crosswalk[major_versions[major]];
            console.log(&#039;Warning: node-pre-gyp could not find exact match for &#039; + target_version);
            console.log(&#039;Warning: but node-pre-gyp successfully choose &#039; + major_versions[major] + &#039; as ABI compatible target&#039;);
          }
        } else if (major === 0) { // node.js
          if (target_parts[1] % 2 === 0) { // for stable/even node.js series
            // look for the last release that is the same minor release
            // e.g. we assume node 0.10.x is ABI compatible with &gt;= 0.10.0
            while (--patch &gt; 0) {
              const new_node_target = &#039;&#039; + major + &#039;.&#039; + minor + &#039;.&#039; + patch;
              if (abi_crosswalk[new_node_target]) {
                cross_obj = abi_crosswalk[new_node_target];
                console.log(&#039;Warning: node-pre-gyp could not find exact match for &#039; + target_version);
                console.log(&#039;Warning: but node-pre-gyp successfully choose &#039; + new_node_target + &#039; as ABI compatible target&#039;);
                break;
              }
            }
          }
        }
      }
      if (!cross_obj) {
        throw new Error(&#039;Unsupported target version: &#039; + target_version);
      }
      // emulate process.versions
      const versions_obj = {
        node: target_version,
        v8: cross_obj.v8 + &#039;.0&#039;,
        // abi_crosswalk uses 1 for node versions lacking process.versions.modules
        // process.versions.modules added in &gt;= v0.10.4 and v0.11.7
        modules: cross_obj.node_abi &gt; 1 ? cross_obj.node_abi : undefined
      };
      return get_node_abi(runtime, versions_obj);
    }
  }
}
module.exports.get_runtime_abi = get_runtime_abi;

const required_parameters = [
  &#039;module_name&#039;,
  &#039;module_path&#039;,
  &#039;host&#039;
];

function validate_config(package_json, opts) {
  const msg = package_json.name + &#039; package.json is not node-pre-gyp ready:\n&#039;;
  const missing = [];
  if (!package_json.main) {
    missing.push(&#039;main&#039;);
  }
  if (!package_json.version) {
    missing.push(&#039;version&#039;);
  }
  if (!package_json.name) {
    missing.push(&#039;name&#039;);
  }
  if (!package_json.binary) {
    missing.push(&#039;binary&#039;);
  }
  const o = package_json.binary;
  if (o) {
    required_parameters.forEach((p) =&gt; {
      if (!o[p] || typeof o[p] !== &#039;string&#039;) {
        missing.push(&#039;binary.&#039; + p);
      }
    });
  }

  if (missing.length &gt;= 1) {
    throw new Error(msg + &#039;package.json must declare these properties: \n&#039; + missing.join(&#039;\n&#039;));
  }
  if (o) {
    // enforce https over http
    const protocol = url.parse(o.host).protocol;
    if (protocol === &#039;http:&#039;) {
      throw new Error(&quot;&#039;host&#039; protocol (&quot; + protocol + &quot;) is invalid - only &#039;https:&#039; is accepted&quot;);
    }
  }
  napi.validate_package_json(package_json, opts);
}

module.exports.validate_config = validate_config;

function eval_template(template, opts) {
  Object.keys(opts).forEach((key) =&gt; {
    const pattern = &#039;{&#039; + key + &#039;}&#039;;
    while (template.indexOf(pattern) &gt; -1) {
      template = template.replace(pattern, opts[key]);
    }
  });
  return template;
}

// url.resolve needs single trailing slash
// to behave correctly, otherwise a double slash
// may end up in the url which breaks requests
// and a lacking slash may not lead to proper joining
function fix_slashes(pathname) {
  if (pathname.slice(-1) !== &#039;/&#039;) {
    return pathname + &#039;/&#039;;
  }
  return pathname;
}

// remove double slashes
// note: path.normalize will not work because
// it will convert forward to back slashes
function drop_double_slashes(pathname) {
  return pathname.replace(/\/\//g, &#039;/&#039;);
}

function get_process_runtime(versions) {
  let runtime = &#039;node&#039;;
  if (versions[&#039;node-webkit&#039;]) {
    runtime = &#039;node-webkit&#039;;
  } else if (versions.electron) {
    runtime = &#039;electron&#039;;
  }
  return runtime;
}

module.exports.get_process_runtime = get_process_runtime;

const default_package_name = &#039;{module_name}-v{version}-{node_abi}-{platform}-{arch}.tar.gz&#039;;
const default_remote_path = &#039;&#039;;

module.exports.evaluate = function(package_json, options, napi_build_version) {
  options = options || {};
  validate_config(package_json, options); // options is a suitable substitute for opts in this case
  const v = package_json.version;
  const module_version = semver.parse(v);
  const runtime = options.runtime || get_process_runtime(process.versions);
  const opts = {
    name: package_json.name,
    configuration: options.debug ? &#039;Debug&#039; : &#039;Release&#039;,
    debug: options.debug,
    module_name: package_json.binary.module_name,
    version: module_version.version,
    prerelease: module_version.prerelease.length ? module_version.prerelease.join(&#039;.&#039;) : &#039;&#039;,
    build: module_version.build.length ? module_version.build.join(&#039;.&#039;) : &#039;&#039;,
    major: module_version.major,
    minor: module_version.minor,
    patch: module_version.patch,
    runtime: runtime,
    node_abi: get_runtime_abi(runtime, options.target),
    node_abi_napi: napi.get_napi_version(options.target) ? &#039;napi&#039; : get_runtime_abi(runtime, options.target),
    napi_version: napi.get_napi_version(options.target), // non-zero numeric, undefined if unsupported
    napi_build_version: napi_build_version || &#039;&#039;,
    node_napi_label: napi_build_version ? &#039;napi-v&#039; + napi_build_version : get_runtime_abi(runtime, options.target),
    target: options.target || &#039;&#039;,
    platform: options.target_platform || process.platform,
    target_platform: options.target_platform || process.platform,
    arch: options.target_arch || process.arch,
    target_arch: options.target_arch || process.arch,
    libc: options.target_libc || detect_libc.familySync() || &#039;unknown&#039;,
    module_main: package_json.main,
    toolset: options.toolset || &#039;&#039;, // address https://github.com/mapbox/node-pre-gyp/issues/119
    bucket: package_json.binary.bucket,
    region: package_json.binary.region,
    s3ForcePathStyle: package_json.binary.s3ForcePathStyle || false
  };
    // support host mirror with npm config `--{module_name}_binary_host_mirror`
    // e.g.: https://github.com/node-inspector/v8-profiler/blob/master/package.json#L25
    // &gt; npm install v8-profiler --profiler_binary_host_mirror=https://npm.taobao.org/mirrors/node-inspector/
  const validModuleName = opts.module_name.replace(&#039;-&#039;, &#039;_&#039;);
  const host = process.env[&#039;npm_config_&#039; + validModuleName + &#039;_binary_host_mirror&#039;] || package_json.binary.host;
  opts.host = fix_slashes(eval_template(host, opts));
  opts.module_path = eval_template(package_json.binary.module_path, opts);
  // now we resolve the module_path to ensure it is absolute so that binding.gyp variables work predictably
  if (options.module_root) {
    // resolve relative to known module root: works for pre-binding require
    opts.module_path = path.join(options.module_root, opts.module_path);
  } else {
    // resolve relative to current working directory: works for node-pre-gyp commands
    opts.module_path = path.resolve(opts.module_path);
  }
  opts.module = path.join(opts.module_path, opts.module_name + &#039;.node&#039;);
  opts.remote_path = package_json.binary.remote_path ? drop_double_slashes(fix_slashes(eval_template(package_json.binary.remote_path, opts))) : default_remote_path;
  const package_name = package_json.binary.package_name ? package_json.binary.package_name : default_package_name;
  opts.package_name = eval_template(package_name, opts);
  opts.staged_tarball = path.join(&#039;build/stage&#039;, opts.remote_path, opts.package_name);
  opts.hosted_path = url.resolve(opts.host, opts.remote_path);
  opts.hosted_tarball = url.resolve(opts.hosted_path, opts.package_name);
  return opts;
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
