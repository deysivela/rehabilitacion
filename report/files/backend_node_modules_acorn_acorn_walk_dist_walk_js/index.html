<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - backend\node_modules\acorn\acorn-walk\dist\walk.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>backend\node_modules\acorn\acorn-walk\dist\walk.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.33</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">461</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">113.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function (global, factory) {
  typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? factory(exports) :
  typeof define === &#039;function&#039; &amp;&amp; define.amd ? define([&#039;exports&#039;], factory) :
  (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));
}(this, function (exports) { &#039;use strict&#039;;

  // AST walker module for Mozilla Parser API compatible trees

  // A simple walk is one where you simply specify callbacks to be
  // called on specific nodes. The last two arguments are optional. A
  // simple use would be
  //
  //     walk.simple(myTree, {
  //         Expression: function(node) { ... }
  //     });
  //
  // to do something with all expressions. All Parser API node types
  // can be used to identify node types, as well as Expression and
  // Statement, which denote categories of nodes.
  //
  // The base argument can be used to pass a custom (recursive)
  // walker, and state can be used to give this walked an initial
  // state.

  function simple(node, visitors, baseVisitor, state, override) {
    if (!baseVisitor) { baseVisitor = base
    ; }(function c(node, st, override) {
      var type = override || node.type, found = visitors[type];
      baseVisitor[type](node, st, c);
      if (found) { found(node, st); }
    })(node, state, override);
  }

  // An ancestor walk keeps an array of ancestor nodes (including the
  // current node) and passes them to the callback as third parameter
  // (and also as state parameter when no other state is present).
  function ancestor(node, visitors, baseVisitor, state, override) {
    var ancestors = [];
    if (!baseVisitor) { baseVisitor = base
    ; }(function c(node, st, override) {
      var type = override || node.type, found = visitors[type];
      var isNew = node !== ancestors[ancestors.length - 1];
      if (isNew) { ancestors.push(node); }
      baseVisitor[type](node, st, c);
      if (found) { found(node, st || ancestors, ancestors); }
      if (isNew) { ancestors.pop(); }
    })(node, state, override);
  }

  // A recursive walk is one where your functions override the default
  // walkers. They can modify and replace the state parameter that&#039;s
  // threaded through the walk, and can opt how and whether to walk
  // their child nodes (by calling their third argument on these
  // nodes).
  function recursive(node, state, funcs, baseVisitor, override) {
    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor
    ;(function c(node, st, override) {
      visitor[override || node.type](node, st, c);
    })(node, state, override);
  }

  function makeTest(test) {
    if (typeof test === &quot;string&quot;)
      { return function (type) { return type === test; } }
    else if (!test)
      { return function () { return true; } }
    else
      { return test }
  }

  var Found = function Found(node, state) { this.node = node; this.state = state; };

  // A full walk triggers the callback on each node
  function full(node, callback, baseVisitor, state, override) {
    if (!baseVisitor) { baseVisitor = base
    ; }(function c(node, st, override) {
      var type = override || node.type;
      baseVisitor[type](node, st, c);
      if (!override) { callback(node, st, type); }
    })(node, state, override);
  }

  // An fullAncestor walk is like an ancestor walk, but triggers
  // the callback on each node
  function fullAncestor(node, callback, baseVisitor, state) {
    if (!baseVisitor) { baseVisitor = base; }
    var ancestors = []
    ;(function c(node, st, override) {
      var type = override || node.type;
      var isNew = node !== ancestors[ancestors.length - 1];
      if (isNew) { ancestors.push(node); }
      baseVisitor[type](node, st, c);
      if (!override) { callback(node, st || ancestors, ancestors, type); }
      if (isNew) { ancestors.pop(); }
    })(node, state);
  }

  // Find a node with a given start, end, and type (all are optional,
  // null can be used as wildcard). Returns a {node, state} object, or
  // undefined when it doesn&#039;t find a matching node.
  function findNodeAt(node, start, end, test, baseVisitor, state) {
    if (!baseVisitor) { baseVisitor = base; }
    test = makeTest(test);
    try {
      (function c(node, st, override) {
        var type = override || node.type;
        if ((start == null || node.start &lt;= start) &amp;&amp;
            (end == null || node.end &gt;= end))
          { baseVisitor[type](node, st, c); }
        if ((start == null || node.start === start) &amp;&amp;
            (end == null || node.end === end) &amp;&amp;
            test(type, node))
          { throw new Found(node, st) }
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the innermost node of a given type that contains the given
  // position. Interface similar to findNodeAt.
  function findNodeAround(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    try {
      (function c(node, st, override) {
        var type = override || node.type;
        if (node.start &gt; pos || node.end &lt; pos) { return }
        baseVisitor[type](node, st, c);
        if (test(type, node)) { throw new Found(node, st) }
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the outermost matching node after a given position.
  function findNodeAfter(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    try {
      (function c(node, st, override) {
        if (node.end &lt; pos) { return }
        var type = override || node.type;
        if (node.start &gt;= pos &amp;&amp; test(type, node)) { throw new Found(node, st) }
        baseVisitor[type](node, st, c);
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the outermost matching node before a given position.
  function findNodeBefore(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    var max
    ;(function c(node, st, override) {
      if (node.start &gt; pos) { return }
      var type = override || node.type;
      if (node.end &lt;= pos &amp;&amp; (!max || max.node.end &lt; node.end) &amp;&amp; test(type, node))
        { max = new Found(node, st); }
      baseVisitor[type](node, st, c);
    })(node, state);
    return max
  }

  // Fallback to an Object.create polyfill for older environments.
  var create = Object.create || function(proto) {
    function Ctor() {}
    Ctor.prototype = proto;
    return new Ctor
  };

  // Used to create a custom walker. Will fill in all missing node
  // type properties with the defaults.
  function make(funcs, baseVisitor) {
    var visitor = create(baseVisitor || base);
    for (var type in funcs) { visitor[type] = funcs[type]; }
    return visitor
  }

  function skipThrough(node, st, c) { c(node, st); }
  function ignore(_node, _st, _c) {}

  // Node walkers.

  var base = {};

  base.Program = base.BlockStatement = function (node, st, c) {
    for (var i = 0, list = node.body; i &lt; list.length; i += 1)
      {
      var stmt = list[i];

      c(stmt, st, &quot;Statement&quot;);
    }
  };
  base.Statement = skipThrough;
  base.EmptyStatement = ignore;
  base.ExpressionStatement = base.ParenthesizedExpression =
    function (node, st, c) { return c(node.expression, st, &quot;Expression&quot;); };
  base.IfStatement = function (node, st, c) {
    c(node.test, st, &quot;Expression&quot;);
    c(node.consequent, st, &quot;Statement&quot;);
    if (node.alternate) { c(node.alternate, st, &quot;Statement&quot;); }
  };
  base.LabeledStatement = function (node, st, c) { return c(node.body, st, &quot;Statement&quot;); };
  base.BreakStatement = base.ContinueStatement = ignore;
  base.WithStatement = function (node, st, c) {
    c(node.object, st, &quot;Expression&quot;);
    c(node.body, st, &quot;Statement&quot;);
  };
  base.SwitchStatement = function (node, st, c) {
    c(node.discriminant, st, &quot;Expression&quot;);
    for (var i$1 = 0, list$1 = node.cases; i$1 &lt; list$1.length; i$1 += 1) {
      var cs = list$1[i$1];

      if (cs.test) { c(cs.test, st, &quot;Expression&quot;); }
      for (var i = 0, list = cs.consequent; i &lt; list.length; i += 1)
        {
        var cons = list[i];

        c(cons, st, &quot;Statement&quot;);
      }
    }
  };
  base.SwitchCase = function (node, st, c) {
    if (node.test) { c(node.test, st, &quot;Expression&quot;); }
    for (var i = 0, list = node.consequent; i &lt; list.length; i += 1)
      {
      var cons = list[i];

      c(cons, st, &quot;Statement&quot;);
    }
  };
  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {
    if (node.argument) { c(node.argument, st, &quot;Expression&quot;); }
  };
  base.ThrowStatement = base.SpreadElement =
    function (node, st, c) { return c(node.argument, st, &quot;Expression&quot;); };
  base.TryStatement = function (node, st, c) {
    c(node.block, st, &quot;Statement&quot;);
    if (node.handler) { c(node.handler, st); }
    if (node.finalizer) { c(node.finalizer, st, &quot;Statement&quot;); }
  };
  base.CatchClause = function (node, st, c) {
    if (node.param) { c(node.param, st, &quot;Pattern&quot;); }
    c(node.body, st, &quot;Statement&quot;);
  };
  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
    c(node.test, st, &quot;Expression&quot;);
    c(node.body, st, &quot;Statement&quot;);
  };
  base.ForStatement = function (node, st, c) {
    if (node.init) { c(node.init, st, &quot;ForInit&quot;); }
    if (node.test) { c(node.test, st, &quot;Expression&quot;); }
    if (node.update) { c(node.update, st, &quot;Expression&quot;); }
    c(node.body, st, &quot;Statement&quot;);
  };
  base.ForInStatement = base.ForOfStatement = function (node, st, c) {
    c(node.left, st, &quot;ForInit&quot;);
    c(node.right, st, &quot;Expression&quot;);
    c(node.body, st, &quot;Statement&quot;);
  };
  base.ForInit = function (node, st, c) {
    if (node.type === &quot;VariableDeclaration&quot;) { c(node, st); }
    else { c(node, st, &quot;Expression&quot;); }
  };
  base.DebuggerStatement = ignore;

  base.FunctionDeclaration = function (node, st, c) { return c(node, st, &quot;Function&quot;); };
  base.VariableDeclaration = function (node, st, c) {
    for (var i = 0, list = node.declarations; i &lt; list.length; i += 1)
      {
      var decl = list[i];

      c(decl, st);
    }
  };
  base.VariableDeclarator = function (node, st, c) {
    c(node.id, st, &quot;Pattern&quot;);
    if (node.init) { c(node.init, st, &quot;Expression&quot;); }
  };

  base.Function = function (node, st, c) {
    if (node.id) { c(node.id, st, &quot;Pattern&quot;); }
    for (var i = 0, list = node.params; i &lt; list.length; i += 1)
      {
      var param = list[i];

      c(param, st, &quot;Pattern&quot;);
    }
    c(node.body, st, node.expression ? &quot;Expression&quot; : &quot;Statement&quot;);
  };

  base.Pattern = function (node, st, c) {
    if (node.type === &quot;Identifier&quot;)
      { c(node, st, &quot;VariablePattern&quot;); }
    else if (node.type === &quot;MemberExpression&quot;)
      { c(node, st, &quot;MemberPattern&quot;); }
    else
      { c(node, st); }
  };
  base.VariablePattern = ignore;
  base.MemberPattern = skipThrough;
  base.RestElement = function (node, st, c) { return c(node.argument, st, &quot;Pattern&quot;); };
  base.ArrayPattern = function (node, st, c) {
    for (var i = 0, list = node.elements; i &lt; list.length; i += 1) {
      var elt = list[i];

      if (elt) { c(elt, st, &quot;Pattern&quot;); }
    }
  };
  base.ObjectPattern = function (node, st, c) {
    for (var i = 0, list = node.properties; i &lt; list.length; i += 1) {
      var prop = list[i];

      if (prop.type === &quot;Property&quot;) {
        if (prop.computed) { c(prop.key, st, &quot;Expression&quot;); }
        c(prop.value, st, &quot;Pattern&quot;);
      } else if (prop.type === &quot;RestElement&quot;) {
        c(prop.argument, st, &quot;Pattern&quot;);
      }
    }
  };

  base.Expression = skipThrough;
  base.ThisExpression = base.Super = base.MetaProperty = ignore;
  base.ArrayExpression = function (node, st, c) {
    for (var i = 0, list = node.elements; i &lt; list.length; i += 1) {
      var elt = list[i];

      if (elt) { c(elt, st, &quot;Expression&quot;); }
    }
  };
  base.ObjectExpression = function (node, st, c) {
    for (var i = 0, list = node.properties; i &lt; list.length; i += 1)
      {
      var prop = list[i];

      c(prop, st);
    }
  };
  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
  base.SequenceExpression = function (node, st, c) {
    for (var i = 0, list = node.expressions; i &lt; list.length; i += 1)
      {
      var expr = list[i];

      c(expr, st, &quot;Expression&quot;);
    }
  };
  base.TemplateLiteral = function (node, st, c) {
    for (var i = 0, list = node.quasis; i &lt; list.length; i += 1)
      {
      var quasi = list[i];

      c(quasi, st);
    }

    for (var i$1 = 0, list$1 = node.expressions; i$1 &lt; list$1.length; i$1 += 1)
      {
      var expr = list$1[i$1];

      c(expr, st, &quot;Expression&quot;);
    }
  };
  base.TemplateElement = ignore;
  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
    c(node.argument, st, &quot;Expression&quot;);
  };
  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
    c(node.left, st, &quot;Expression&quot;);
    c(node.right, st, &quot;Expression&quot;);
  };
  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
    c(node.left, st, &quot;Pattern&quot;);
    c(node.right, st, &quot;Expression&quot;);
  };
  base.ConditionalExpression = function (node, st, c) {
    c(node.test, st, &quot;Expression&quot;);
    c(node.consequent, st, &quot;Expression&quot;);
    c(node.alternate, st, &quot;Expression&quot;);
  };
  base.NewExpression = base.CallExpression = function (node, st, c) {
    c(node.callee, st, &quot;Expression&quot;);
    if (node.arguments)
      { for (var i = 0, list = node.arguments; i &lt; list.length; i += 1)
        {
          var arg = list[i];

          c(arg, st, &quot;Expression&quot;);
        } }
  };
  base.MemberExpression = function (node, st, c) {
    c(node.object, st, &quot;Expression&quot;);
    if (node.computed) { c(node.property, st, &quot;Expression&quot;); }
  };
  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
    if (node.declaration)
      { c(node.declaration, st, node.type === &quot;ExportNamedDeclaration&quot; || node.declaration.id ? &quot;Statement&quot; : &quot;Expression&quot;); }
    if (node.source) { c(node.source, st, &quot;Expression&quot;); }
  };
  base.ExportAllDeclaration = function (node, st, c) {
    c(node.source, st, &quot;Expression&quot;);
  };
  base.ImportDeclaration = function (node, st, c) {
    for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1)
      {
      var spec = list[i];

      c(spec, st);
    }
    c(node.source, st, &quot;Expression&quot;);
  };
  base.ImportExpression = function (node, st, c) {
    c(node.source, st, &quot;Expression&quot;);
  };
  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

  base.TaggedTemplateExpression = function (node, st, c) {
    c(node.tag, st, &quot;Expression&quot;);
    c(node.quasi, st, &quot;Expression&quot;);
  };
  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, &quot;Class&quot;); };
  base.Class = function (node, st, c) {
    if (node.id) { c(node.id, st, &quot;Pattern&quot;); }
    if (node.superClass) { c(node.superClass, st, &quot;Expression&quot;); }
    c(node.body, st);
  };
  base.ClassBody = function (node, st, c) {
    for (var i = 0, list = node.body; i &lt; list.length; i += 1)
      {
      var elt = list[i];

      c(elt, st);
    }
  };
  base.MethodDefinition = base.Property = function (node, st, c) {
    if (node.computed) { c(node.key, st, &quot;Expression&quot;); }
    c(node.value, st, &quot;Expression&quot;);
  };

  exports.ancestor = ancestor;
  exports.base = base;
  exports.findNodeAfter = findNodeAfter;
  exports.findNodeAround = findNodeAround;
  exports.findNodeAt = findNodeAt;
  exports.findNodeBefore = findNodeBefore;
  exports.full = full;
  exports.fullAncestor = fullAncestor;
  exports.make = make;
  exports.recursive = recursive;
  exports.simple = simple;

  Object.defineProperty(exports, &#039;__esModule&#039;, { value: true });

}));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
