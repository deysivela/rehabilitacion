<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - backend\node_modules\@mapbox\node-pre-gyp\lib\install.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>backend\node_modules\@mapbox\node-pre-gyp\lib\install.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">235</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">35.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.70</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

module.exports = exports = install;

exports.usage = &#039;Attempts to install pre-built binary for module&#039;;

const fs = require(&#039;fs&#039;);
const path = require(&#039;path&#039;);
const log = require(&#039;npmlog&#039;);
const existsAsync = fs.exists || path.exists;
const versioning = require(&#039;./util/versioning.js&#039;);
const napi = require(&#039;./util/napi.js&#039;);
const makeDir = require(&#039;make-dir&#039;);
// for fetching binaries
const fetch = require(&#039;node-fetch&#039;);
const tar = require(&#039;tar&#039;);

let npgVersion = &#039;unknown&#039;;
try {
  // Read own package.json to get the current node-pre-pyp version.
  const ownPackageJSON = fs.readFileSync(path.join(__dirname, &#039;..&#039;, &#039;package.json&#039;), &#039;utf8&#039;);
  npgVersion = JSON.parse(ownPackageJSON).version;
} catch (e) {
  // do nothing
}

function place_binary(uri, targetDir, opts, callback) {
  log.http(&#039;GET&#039;, uri);

  // Try getting version info from the currently running npm.
  const envVersionInfo = process.env.npm_config_user_agent ||
        &#039;node &#039; + process.version;

  const sanitized = uri.replace(&#039;+&#039;, &#039;%2B&#039;);
  const requestOpts = {
    uri: sanitized,
    headers: {
      &#039;User-Agent&#039;: &#039;node-pre-gyp (v&#039; + npgVersion + &#039;, &#039; + envVersionInfo + &#039;)&#039;
    },
    follow_max: 10
  };

  if (opts.cafile) {
    try {
      requestOpts.ca = fs.readFileSync(opts.cafile);
    } catch (e) {
      return callback(e);
    }
  } else if (opts.ca) {
    requestOpts.ca = opts.ca;
  }

  const proxyUrl = opts.proxy ||
                    process.env.http_proxy ||
                    process.env.HTTP_PROXY ||
                    process.env.npm_config_proxy;
  let agent;
  if (proxyUrl) {
    const ProxyAgent = require(&#039;https-proxy-agent&#039;);
    agent = new ProxyAgent(proxyUrl);
    log.http(&#039;download&#039;, &#039;proxy agent configured using: &quot;%s&quot;&#039;, proxyUrl);
  }

  fetch(sanitized, { agent })
    .then((res) =&gt; {
      if (!res.ok) {
        throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);
      }
      const dataStream = res.body;

      return new Promise((resolve, reject) =&gt; {
        let extractions = 0;
        const countExtractions = (entry) =&gt; {
          extractions += 1;
          log.info(&#039;install&#039;, &#039;unpacking %s&#039;, entry.path);
        };

        dataStream.pipe(extract(targetDir, countExtractions))
          .on(&#039;error&#039;, (e) =&gt; {
            reject(e);
          });
        dataStream.on(&#039;end&#039;, () =&gt; {
          resolve(`extracted file count: ${extractions}`);
        });
        dataStream.on(&#039;error&#039;, (e) =&gt; {
          reject(e);
        });
      });
    })
    .then((text) =&gt; {
      log.info(text);
      callback();
    })
    .catch((e) =&gt; {
      log.error(`install ${e.message}`);
      callback(e);
    });
}

function extract(to, onentry) {
  return tar.extract({
    cwd: to,
    strip: 1,
    onentry
  });
}

function extract_from_local(from, targetDir, callback) {
  if (!fs.existsSync(from)) {
    return callback(new Error(&#039;Cannot find file &#039; + from));
  }
  log.info(&#039;Found local file to extract from &#039; + from);

  // extract helpers
  let extractCount = 0;
  function countExtractions(entry) {
    extractCount += 1;
    log.info(&#039;install&#039;, &#039;unpacking &#039; + entry.path);
  }
  function afterExtract(err) {
    if (err) return callback(err);
    if (extractCount === 0) {
      return callback(new Error(&#039;There was a fatal problem while extracting the tarball&#039;));
    }
    log.info(&#039;tarball&#039;, &#039;done parsing tarball&#039;);
    callback();
  }

  fs.createReadStream(from).pipe(extract(targetDir, countExtractions))
    .on(&#039;close&#039;, afterExtract)
    .on(&#039;error&#039;, afterExtract);
}

function do_build(gyp, argv, callback) {
  const args = [&#039;rebuild&#039;].concat(argv);
  gyp.todo.push({ name: &#039;build&#039;, args: args });
  process.nextTick(callback);
}

function print_fallback_error(err, opts, package_json) {
  const fallback_message = &#039; (falling back to source compile with node-gyp)&#039;;
  let full_message = &#039;&#039;;
  if (err.statusCode !== undefined) {
    // If we got a network response it but failed to download
    // it means remote binaries are not available, so let&#039;s try to help
    // the user/developer with the info to debug why
    full_message = &#039;Pre-built binaries not found for &#039; + package_json.name + &#039;@&#039; + package_json.version;
    full_message += &#039; and &#039; + opts.runtime + &#039;@&#039; + (opts.target || process.versions.node) + &#039; (&#039; + opts.node_abi + &#039; ABI, &#039; + opts.libc + &#039;)&#039;;
    full_message += fallback_message;
    log.warn(&#039;Tried to download(&#039; + err.statusCode + &#039;): &#039; + opts.hosted_tarball);
    log.warn(full_message);
    log.http(err.message);
  } else {
    // If we do not have a statusCode that means an unexpected error
    // happened and prevented an http response, so we output the exact error
    full_message = &#039;Pre-built binaries not installable for &#039; + package_json.name + &#039;@&#039; + package_json.version;
    full_message += &#039; and &#039; + opts.runtime + &#039;@&#039; + (opts.target || process.versions.node) + &#039; (&#039; + opts.node_abi + &#039; ABI, &#039; + opts.libc + &#039;)&#039;;
    full_message += fallback_message;
    log.warn(full_message);
    log.warn(&#039;Hit error &#039; + err.message);
  }
}

//
// install
//
function install(gyp, argv, callback) {
  const package_json = gyp.package_json;
  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);
  const source_build = gyp.opts[&#039;build-from-source&#039;] || gyp.opts.build_from_source;
  const update_binary = gyp.opts[&#039;update-binary&#039;] || gyp.opts.update_binary;
  const should_do_source_build = source_build === package_json.name || (source_build === true || source_build === &#039;true&#039;);
  if (should_do_source_build) {
    log.info(&#039;build&#039;, &#039;requesting source compile&#039;);
    return do_build(gyp, argv, callback);
  } else {
    const fallback_to_build = gyp.opts[&#039;fallback-to-build&#039;] || gyp.opts.fallback_to_build;
    let should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === &#039;true&#039;);
    // but allow override from npm
    if (process.env.npm_config_argv) {
      const cooked = JSON.parse(process.env.npm_config_argv).cooked;
      const match = cooked.indexOf(&#039;--fallback-to-build&#039;);
      if (match &gt; -1 &amp;&amp; cooked.length &gt; match &amp;&amp; cooked[match + 1] === &#039;false&#039;) {
        should_do_fallback_build = false;
        log.info(&#039;install&#039;, &#039;Build fallback disabled via npm flag: --fallback-to-build=false&#039;);
      }
    }
    let opts;
    try {
      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);
    } catch (err) {
      return callback(err);
    }

    opts.ca = gyp.opts.ca;
    opts.cafile = gyp.opts.cafile;

    const from = opts.hosted_tarball;
    const to = opts.module_path;
    const binary_module = path.join(to, opts.module_name + &#039;.node&#039;);
    existsAsync(binary_module, (found) =&gt; {
      if (!update_binary) {
        if (found) {
          console.log(&#039;[&#039; + package_json.name + &#039;] Success: &quot;&#039; + binary_module + &#039;&quot; already installed&#039;);
          console.log(&#039;Pass --update-binary to reinstall or --build-from-source to recompile&#039;);
          return callback();
        }
        log.info(&#039;check&#039;, &#039;checked for &quot;&#039; + binary_module + &#039;&quot; (not found)&#039;);
      }

      makeDir(to).then(() =&gt; {
        const fileName = from.startsWith(&#039;file://&#039;) &amp;&amp; from.slice(&#039;file://&#039;.length);
        if (fileName) {
          extract_from_local(fileName, to, after_place);
        } else {
          place_binary(from, to, opts, after_place);
        }
      }).catch((err) =&gt; {
        after_place(err);
      });

      function after_place(err) {
        if (err &amp;&amp; should_do_fallback_build) {
          print_fallback_error(err, opts, package_json);
          return do_build(gyp, argv, callback);
        } else if (err) {
          return callback(err);
        } else {
          console.log(&#039;[&#039; + package_json.name + &#039;] Success: &quot;&#039; + binary_module + &#039;&quot; is installed via remote&#039;);
          return callback();
        }
      }
    });
  }
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
